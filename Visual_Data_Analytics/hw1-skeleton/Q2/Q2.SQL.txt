-- Setup. DO NOT REMOVE.
.headers on
.separator ','

DROP TABLE IF EXISTS sets;
DROP TABLE IF EXISTS themes;
DROP TABLE IF EXISTS parts;
DROP VIEW IF EXISTS top_level_themes;
DROP VIEW IF EXISTS sets_years;
DROP TABLE IF EXISTS parts_fts;


-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (a.i) Create tables

-- [insert your SQL statement(s) BELOW this line]

CREATE TABLE sets (set_num TEXT, name TEXT, year INTEGER, theme_id INTEGER, num_parts INTEGER);
CREATE TABLE themes (id INTEGER, name TEXT, parent_id INTEGER);
CREATE TABLE parts (part_num TEXT, name TEXT, part_cat_id INTEGER, part_material_id INTEGER);

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.tables
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (a.ii) Import data

-- [insert your SQLite command(s) BELOW this line]

.import data/sets.csv sets
.import data/themes.csv themes
.import data/parts.csv parts

-- [insert your SQLite command(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.headers off
SELECT count(*) FROM sqlite_master WHERE type='table' AND name='sets';
SELECT count(*) FROM sqlite_master WHERE type='table' AND name='parts';
SELECT count(*) FROM sqlite_master WHERE type='table' AND name='themes';
.headers on
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (b) Create indexes

-- [insert your SQL statement(s) BELOW this line]

CREATE INDEX sets_index ON sets(set_num);
CREATE INDEX parts_index ON parts(part_num);
CREATE INDEX themes_index ON themes(id);

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.indexes
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (c.i) Create the top_level themes VIEW

-- [insert your SQL statement(s) BELOW this line]

CREATE VIEW top_level_themes AS SELECT id, name FROM themes WHERE parent_id = '' OR parent_id IS NULL;

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.headers off
PRAGMA table_info(top_level_themes);
.headers on
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (c.ii) count the top level themes in the top_level_themes view.

-- [insert your SQL statement(s) BELOW this line]

SELECT COUNT(*) AS count FROM top_level_themes;

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (d) Finding top level themes with the most sets.

-- [insert your SQL statement(s) BELOW this line]

SELECT a.name AS theme, COUNT(*) as num_sets FROM top_level_themes AS a INNER JOIN sets AS b on a.id=b.theme_id GROUP BY a.name HAVING num_sets > 25 ORDER BY num_sets DESC LIMIT 10;


-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (e) Calculate a percentage

-- [insert your SQL statement(s) BELOW this line]

CREATE VIEW counts AS SELECT a.name, COUNT(*) as cnt FROM top_level_themes AS a INNER JOIN sets AS b on a.id=b.theme_id GROUP BY a.name;

SELECT a.name AS theme, printf("%.2f", (COUNT(*) * 1.0 / t.total) * 100.00) AS percentage FROM top_level_themes AS a, (SELECT SUM(cnt) AS total FROM counts) AS t INNER JOIN sets AS b on a.id=b.theme_id GROUP BY a.name HAVING CAST(percentage AS decimal) >=5.00  ORDER BY CAST(percentage AS decimal) DESC;

-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (f) Summarize a sub-theme

-- [insert your SQL statement(s) BELOW this line]
CREATE VIEW subthemes AS SELECT * FROM themes WHERE parent_id IS NOT NULL AND parent_id != '';
SELECT a.name AS sub_theme, COUNT(*) AS num_sets FROM subthemes AS a INNER JOIN sets AS b ON a.id=b.theme_id GROUP BY a.name HAVING num_sets > 5 ORDER BY num_sets DESC, a.name;



-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (g.i.) Create the sets VIEW

-- [insert your SQL statement(s) BELOW this line]
CREATE VIEW sets_years AS SELECT ROWID, year, COUNT(*) AS sets_count FROM sets GROUP BY year;



-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.headers off
PRAGMA table_info(sets_years);
SELECT count(*) FROM sqlite_master WHERE type='table' AND name='sets_years';
.headers on
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (g.ii) Find the running total of sets in the Rebrickable database each year

-- [insert your SQL statement(s) BELOW this line]
SELECT a.year AS year, SUM(b.sets_count) AS running_total FROM sets_years AS a, sets_years AS b WHERE b.year <= a.year GROUP BY a.year HAVING a.year >= 1980 AND a.year < 1990;



-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (h) Create the FTS table and import data.

-- [insert your SQL statement(s) BELOW this line]

CREATE VIRTUAL TABLE parts_fts USING fts4(part_num text, name text, part_cat_id integer, part_material_id integer);
.import data/parts.csv parts_fts


-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]

.headers off
PRAGMA table_info(parts_fts);
.headers on
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (h.i) Count the number of unique parts whose name field begins with the prefix ‘mini’.

-- [insert your SQL statement(s) BELOW this line]
SELECT COUNT(DISTINCT part_num) AS count_overview FROM parts_fts WHERE name LIKE 'mini%';



-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (h.ii) List the part_num’s of the unique parts that contain the terms ‘minidoll’ and ‘boy’ in the name field with no more than 5 intervening terms.

-- [insert your SQL statement(s) BELOW this line]
SELECT COUNT(DISTINCT part_num) AS total_boy_minidoll FROM parts_fts WHERE name MATCH '*minidoll* NEAR/5 *boy* OR *boy* NEAR/5 *minidoll*';



-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --

-- (h.iii) List the part_num’s of the unique parts that contain the terms ‘minidoll’ and ‘girl’ in the name field with no more than 5 intervening terms.

-- [insert your SQL statement(s) BELOW this line]
SELECT COUNT(DISTINCT part_num) AS total_girl_minidoll FROM parts_fts WHERE name MATCH '*minidoll* NEAR/5 *girl* OR *girl* NEAR/5 *minidoll*';




-- [insert your SQL statement(s) ABOVE this line]

-- [the following statement(s) are for autograding. DO NOT REMOVE.]
.print '~~~~~'

-- ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** --
